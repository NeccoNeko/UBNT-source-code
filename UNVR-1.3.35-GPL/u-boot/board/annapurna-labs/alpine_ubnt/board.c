/**
 * board/annapurna-labs/alpine_ubnt/board.c
 *
 * Thie file contains board specific functionality.
 * Board: Annapurna Labs Alpine Development Board
 *
 * Copyright (C) 2018 Ubiquitie Networks Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <errno.h>
#include <common.h>
#include <libfdt_env.h>
#include <fdt_support.h>
#include <libfdt.h>
#include <fdtdec.h>
#include <linux/compiler.h>
#include <asm/io.h>
#include <asm/global_data.h>
#include <spi.h>
#include <scsi.h>
#include <asm/arch/timer.h>
#include <malloc.h>
#include <spi_flash.h>
#include <i2c.h>
#include <pca953x.h>

#include <al_globals.h>
#include <al_board.h>
#include <shared_params.h>
#include <al_eth.h>
#include <al_hal_pbs_regs.h>
#include <al_hal_nb_regs.h>
#include <al_hal_cmos_regs.h>
#include <al_hal_unit_adapter_regs.h>
#include <al_hal_addr_map.h>
#include <al_init_sys_fabric.h>

#include "dev_info_layout.h"
#include "generated/version_autogenerated.h"
#include "lcd.h"
#include "board_cfg.h"
#include "eeprom_per_device.h"
#include "al_flash_contents.h"
#include "early_nand.h"
#include "dt_based_sgpo_init.h"
#ifdef CONFIG_AL_TRACE
#include "al_serial_trace.h"
#endif

#define I2C_ADDR_LEN		2

#define DT_OFFSET_STR      "dt_location"
#define I2C_PROBE_ADDR_STR "pld_i2c_addr"

#define PCI_REGS_IO_SYS_BASE_IDX	11
#define PCI_REGS_IO_SIZE_IDX		13
#define PCI_REGS_MEM_REAL_BASE_IDX	16
#define PCI_REGS_MEM_SYS_BASE_IDX	18
#define PCI_REGS_MEM_SIZE_IDX		20

#define NAND_CTRL_BASE_OFFSET		0x201000

#define DEV_INFO_FIELD(field)\
	((dev_info_buff[DEV_INFO_ ## field ## _OFFSET] &\
	 DEV_INFO_ ## field ## _MASK) >> DEV_INFO_ ## field ## _SHIFT)

DECLARE_GLOBAL_DATA_PTR;

static unsigned int dt_offset = 0xc0000; /* Default Value */
static unsigned int dt_is_from_toc;

static unsigned int i2c_mux_ch0_bus_id = 1;

static struct al_pcie_cfg pcie_cfg[AL_SB_PCIE_NUM] = {
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
#if (AL_SB_PCIE_NUM > 3)
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
#endif
};

static struct {
	const enum al_muio_mux_if iface;
	const char *iface_str;
} ifaces_list[] = {
	{ AL_MUIO_MUX_IF_NOR_8,		"if_nor_8" },
	{ AL_MUIO_MUX_IF_NOR_16,	"if_nor_16" },
	{ AL_MUIO_MUX_IF_NOR_CS_0,	"if_nor_cs_0" },
	{ AL_MUIO_MUX_IF_NOR_CS_1,	"if_nor_cs_1" },
	{ AL_MUIO_MUX_IF_NOR_CS_2,	"if_nor_cs_2" },
	{ AL_MUIO_MUX_IF_NOR_CS_3,	"if_nor_cs_3" },
	{ AL_MUIO_MUX_IF_NOR_WP,	"if_nor_wp" },
	{ AL_MUIO_MUX_IF_NAND_8,	"if_nand_8" },
	{ AL_MUIO_MUX_IF_NAND_16,	"if_nand_16" },
	{ AL_MUIO_MUX_IF_NAND_CS_0,	"if_nand_cs_0" },
	{ AL_MUIO_MUX_IF_NAND_CS_1,	"if_nand_cs_1" },
	{ AL_MUIO_MUX_IF_NAND_CS_2,	"if_nand_cs_2" },
	{ AL_MUIO_MUX_IF_NAND_CS_3,	"if_nand_cs_3" },
	{ AL_MUIO_MUX_IF_NAND_WP,	"if_nand_wp" },
	{ AL_MUIO_MUX_IF_SRAM_8,	"if_sram_8" },
	{ AL_MUIO_MUX_IF_SRAM_16,	"if_sram_16" },
	{ AL_MUIO_MUX_IF_SRAM_CS_0,	"if_sram_cs_0" },
	{ AL_MUIO_MUX_IF_SRAM_CS_1,	"if_sram_cs_1" },
	{ AL_MUIO_MUX_IF_SRAM_CS_2,	"if_sram_cs_2" },
	{ AL_MUIO_MUX_IF_SRAM_CS_3,	"if_sram_cs_3" },
	{ AL_MUIO_MUX_IF_SATA_0_LEDS,	"if_sata_0_leds" },
	{ AL_MUIO_MUX_IF_SATA_1_LEDS,	"if_sata_1_leds" },
	{ AL_MUIO_MUX_IF_ETH_0_LED,	"if_eth_0_led" },
	{ AL_MUIO_MUX_IF_ETH_1_LED,	"if_eth_1_led" },
	{ AL_MUIO_MUX_IF_ETH_2_LED,	"if_eth_2_led" },
	{ AL_MUIO_MUX_IF_ETH_3_LED,	"if_eth_3_led" },
	{ AL_MUIO_MUX_IF_ETH_LEDS,	"if_eth_leds" },
	{ AL_MUIO_MUX_IF_ETH_GPIO,	"if_eth_gpio" },
	{ AL_MUIO_MUX_IF_UART_1,	"if_uart_1" },
	{ AL_MUIO_MUX_IF_UART_1_MODEM,	"if_uart_1_modem" },
	{ AL_MUIO_MUX_IF_UART_2,	"if_uart_2" },
	{ AL_MUIO_MUX_IF_UART_3,	"if_uart_3" },
	{ AL_MUIO_MUX_IF_I2C_GEN,	"if_i2c_gen" },
	{ AL_MUIO_MUX_IF_ULPI_0_RST_N,	"if_ulpi_0_rst_n" },
	{ AL_MUIO_MUX_IF_ULPI_1_RST_N,	"if_ulpi_1_rst_n" },
	{ AL_MUIO_MUX_IF_PCI_EP_INT_A,	"if_pci_ep_int_a" },
	{ AL_MUIO_MUX_IF_PCI_EP_RESET_OUT, "if_pci_ep_reset_out" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_1,	"if_spim_a_ss_1" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_2,	"if_spim_a_ss_2" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_3,	"if_spim_a_ss_3" },
	{ AL_MUIO_MUX_IF_ULPI_1_B,	"if_ulpi_1_b" },
	{ AL_MUIO_MUX_IF_GPIO,		"if_gpio" },
	{ AL_MUIO_MUX_IF_SGPO_CLK,	"if_sgpo_clk" },
	{ AL_MUIO_MUX_IF_SGPO_DS_0,	"if_sgpo_ds_0" },
	{ AL_MUIO_MUX_IF_SGPO_DS_1,	"if_sgpo_ds_1" },
	{ AL_MUIO_MUX_IF_SGPO_DS_2,	"if_sgpo_ds_2" },
	{ AL_MUIO_MUX_IF_SGPO_DS_3,	"if_sgpo_ds_3" },
	{ AL_MUIO_MUX_IF_SPIM_AUX,	"if_spim_aux" },
	{ AL_MUIO_MUX_IF_TDM,		"if_tdm" },
};

static unsigned int ifaces_num = sizeof(ifaces_list) / sizeof(ifaces_list[0]);

/*
 * this read function-pointer enables the system to choose boot device on
 * runtime, according to provided bootstrap
 */
int (*boot_read)(unsigned int, void *, unsigned int);

static int recovery;

static int obj_hdr_dt_valid;
static struct al_flash_obj_hdr obj_hdr_dt;
static unsigned int obj_hdr_dt_offset;

static int obj_hdr_uboot_script_valid;
static struct al_flash_obj_hdr obj_hdr_uboot_script;
static unsigned int obj_hdr_uboot_script_offset;

static unsigned int boot_instance_num_active;
static unsigned int boot_instance_num_active_fallback;
static unsigned int boot_instance_num_non_active;

/* Get the required Ethernet board params reference clock frequency */
static enum al_eth_ref_clk_freq eth_board_params_ref_clk_freq_get(void)
{
	switch (al_globals.bootstraps.sb_clk_freq) {
	default:
		printf("%s: invalid SB clock frequency (%u)\n", __func__,
			al_globals.bootstraps.sb_clk_freq);
	case 375000000:
		return AL_ETH_REF_FREQ_375_MHZ;
	case 250000000:
		return AL_ETH_REF_FREQ_250_MHZ;
	case 500000000:
		return AL_ETH_REF_FREQ_500_MHZ;
	};
}

int spi_boot_read(unsigned int offset, void *target, unsigned int size)
{
	int err;
	static struct spi_flash *flash = NULL;

	if (!flash)
		flash = spi_flash_probe(
			0, 0, CONFIG_SF_DEFAULT_SPEED, CONFIG_SF_DEFAULT_MODE);

	if (!flash)
		return -EIO;

	err = spi_flash_read(
		flash, offset, size, target);
	if (err)
		return err;

	return 0;
}

/*
 * When booting from UART, assume entire boot image was loaded through
 * UART, and set a recovery offset accordingly
 */
int recovery_mem_read(unsigned int offset, void *target, unsigned int size)
{
	memcpy(target, (uint8_t *)(uintptr_t)offset + AL_RECOVERY_OFFSET, size);

	return 0;
}

static int toc_parse(void)
{
	int err;
	int found_index;
	struct al_flash_toc_entry toc_entry;
	al_bool env_instance_fallback = AL_FALSE;

	err = al_flash_toc_search((al_flash_dev_read)boot_read,
		CONFIG_AL_FLASH_TOC_FIRST_OFFSET,
		CONFIG_AL_FLASH_TOC_SKIP_SIZE,
		CONFIG_AL_FLASH_TOC_MAX_NUM_SKIPS,
		&al_globals.toc_offset);
	if (err) {
		printf("al_flash_toc_search failed!\n");
		return err;
	}

	err = al_flash_toc_stage2_active_instance_get_with_fallback(
		(void *)AL_PBS_INT_MEM_SRAM_BASE,
		STAGE2_ACTUAL_OFFSET_ADDR_IN_PBS_SRAM,
		(al_flash_dev_read)boot_read, al_globals.toc_offset,
		&boot_instance_num_active,
		&boot_instance_num_active_fallback);
	if (err) {
		printf("al_flash_toc_stage2_active_instance_get failed!\n");
		boot_instance_num_active = 0;
		boot_instance_num_active_fallback = 0;
	}

	boot_instance_num_non_active =
		(boot_instance_num_active == 0) ? 1 :
		((boot_instance_num_active == 1) ? 0 :
		((boot_instance_num_active == 2) ? 3 : 2));

	err = al_flash_toc_find_id_with_fallback(
		(al_flash_dev_read)boot_read,
		al_globals.toc_offset,
		AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_DT, boot_instance_num_active),
		AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_DT, boot_instance_num_active_fallback),
		0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_uboot_script;
	}
	if (found_index < 0) {
		printf("DT not found in TOC!\n");
		goto get_uboot_script;
	}

	err = al_flash_obj_header_read_and_validate((al_flash_dev_read)boot_read, toc_entry.offset, &obj_hdr_dt);
	if (err) {
		printf("al_flash_obj_header_read_and_validate failed!\n");
		goto get_uboot_script;
	}

	obj_hdr_dt_offset = toc_entry.offset;
	obj_hdr_dt_valid = 1;

get_uboot_script:
	err = al_flash_toc_find_id_with_fallback(
		(al_flash_dev_read)boot_read,
		al_globals.toc_offset,
		AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_UBOOT_SCRIPT, boot_instance_num_active),
		AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_UBOOT_SCRIPT, boot_instance_num_active_fallback),
		0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_env_offset;
	}
	if (found_index < 0) {
		printf("U-Boot script not found in TOC!\n");
		goto get_env_offset;
	}

	err = al_flash_obj_header_read_and_validate((al_flash_dev_read)boot_read, toc_entry.offset, &obj_hdr_uboot_script);
	if (err) {
		printf("al_flash_obj_header_read_and_validate failed!\n");
		goto get_env_offset;
	}

	obj_hdr_uboot_script_offset = toc_entry.offset;
	obj_hdr_uboot_script_valid = 1;

get_env_offset:
	err = al_flash_toc_find_id_with_fallback(
		(al_flash_dev_read)boot_read,
		al_globals.toc_offset,
		AL_FLASH_OBJ_ID(
			AL_FLASH_OBJ_ID_UBOOT_ENV,
			env_instance_fallback ? 0 : boot_instance_num_active),
		AL_FLASH_OBJ_ID(
			AL_FLASH_OBJ_ID_UBOOT_ENV,
			env_instance_fallback ? 0 : boot_instance_num_active_fallback),
		0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_env_offset_redund;
	}
	if (found_index < 0) {
		if ((!env_instance_fallback) && (boot_instance_num_active)) {
			printf("U-Boot environment not found in TOC - falling back to instance 0!\n");
			env_instance_fallback = AL_TRUE;
			goto get_env_offset;
		} else {
			printf("U-Boot environment not found in TOC!\n");
		}
		al_globals.env_offset_valid = 0;
		goto get_env_offset_redund;
	}

	al_globals.env_offset = toc_entry.offset;
	al_globals.env_offset_valid = 1;

get_env_offset_redund:
	err = al_flash_toc_find_id_with_fallback(
		(al_flash_dev_read)boot_read,
		al_globals.toc_offset,
		AL_FLASH_OBJ_ID(
			AL_FLASH_OBJ_ID_UBOOT_ENV_RED,
			env_instance_fallback ? 0 : boot_instance_num_active),
		AL_FLASH_OBJ_ID(
			AL_FLASH_OBJ_ID_UBOOT_ENV_RED,
			env_instance_fallback ? 0 : boot_instance_num_active_fallback),
		0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto done;
	}
	if (found_index < 0) {
		printf("U-Boot redundant environment not found in TOC!\n");
		al_globals.env_redund_offset_valid = 0;
		goto done;
	}

	al_globals.env_redund_offset = toc_entry.offset;
	al_globals.env_redund_offset_valid = 1;

done:
	return 0;
}

static int dt_read(void)
{
	volatile uint8_t *dev_info_buff = (volatile uint8_t *)DEV_INFO_BASE;
	int err;

	working_fdt = malloc(CONFIG_AL_DT_MAX_SIZE);
	if (!working_fdt)
		return -ENOMEM;

	/*
	 * When boot from UART, assume entire boot image was loaded through
	 * UART
	 */
	if ((!DEV_INFO_FIELD(RSVD_SPI_LOAD)) &&
		((DEV_INFO_FIELD(RSVD_XMODEM_LOAD)) ||
		al_globals.bootstraps.boot_device == BOOT_DEVICE_UART)) {
		boot_read = recovery_mem_read;
		recovery = 1;
	} else if (al_globals.bootstraps.boot_device == BOOT_DEVICE_NAND_8BIT) {
		err = early_nand_init();
		if (err)
			printf("%s: early_nand_init failed!\n", __func__);
		BUG_ON(err);
		boot_read = early_nand_read;
	} else {
		/* SPI FLASH */
		boot_read = spi_boot_read;
	}

	/* TOC parse */
	err = toc_parse();
	if (err)
		printf("%s: TOC parsing failed!\n", __func__);

	if (obj_hdr_dt_valid) {
		int err;

		err = al_flash_obj_data_load((al_flash_dev_read)boot_read, obj_hdr_dt_offset, working_fdt);
		if (err) {
			printf("al_flash_obj_data_load failed!\n");
			return -EINVAL;
		}

		dt_offset = obj_hdr_dt_offset;
		dt_is_from_toc = 1;
	} else {
		err = boot_read(dt_offset, working_fdt, CONFIG_AL_DT_MAX_SIZE);
		if (err)
			return err;
	}

	return 0;
}

static int dt_based_init_pinctrl(void)
{
	int off;
	const u32 *cell;
	const char *prop;
	const struct fdt_property *fdt_prop;
	int len;
	int i;
	int cell_idx;
	int err;

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/pinctrl_init");
	if (off < 0) {
		printf("%s: pinctrl initialization node not found!\n", __func__);
		return -EINVAL;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "pinctrl-0", &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, "pinctrl-0");
		return -EINVAL;
	}

	cell = (u32 *)fdt_prop->data;
	len /= sizeof(u32);

	debug("Muxed interfaces:\n");

	for (cell_idx = 0; cell_idx < len; cell_idx++, cell++) {
		enum al_muio_mux_if iface;
		int iface_arg;

		off = fdt_node_offset_by_phandle(working_fdt, fdt32_to_cpu(*cell));

		prop = (char *)fdt_getprop(working_fdt, off, "id", NULL);
		if (!prop)
			return -EINVAL;

		iface_arg = fdtdec_get_int(working_fdt, off, "arg", 0);

		debug("\t%s(%d)\n", prop, iface_arg);

		for (i = 0; i < ifaces_num; ++i) {
			if (!strcmp(ifaces_list[i].iface_str, prop)) {
				iface = ifaces_list[i].iface;
				break;
			}
		}

		if (i == ifaces_num) {
			printf("%s: invalid iface (%s)!\n\n", __func__, prop);
			return -EINVAL;
		}

		err = al_muio_mux_iface_alloc(
			&al_globals.muio_mux,
			iface,
			iface_arg);
		if (err) {
			printf(
				"al_muio_mux_iface_alloc failed, either due to "
				"interface conflict, or syntax error!\n\n");
			return -1;

		}
	}

	return 0;
};

static int dt_based_init_gpio(void)
{
	int off;
	const u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	int entry_idx;
	int err;
	struct gpio_cfg_ent gpio_cfg[AL_GPIO_TOTAL_PIN_AMOUNT];

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/gpio_init");
	if (off < 0) {
		printf("%s: gpio initialization node not found!\n", __func__);
		return -EINVAL;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "gpio-list", &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, "gpio-list");
		return -EINVAL;
	}

	cell = (u32 *)fdt_prop->data;
	len /= sizeof(u32);

	debug("GPIO configuration:\n");

	if (len % 3) {
		printf("%s: property 'gpio-list' must contain GPIO triplets!\n",
			__func__);
		return -EINVAL;
	}

	len /= 3;

	for (entry_idx = 0; entry_idx < len; entry_idx++, cell += 3) {
		int gpio_num = fdt32_to_cpu(cell[0]);
		int is_output = fdt32_to_cpu(cell[1]);
		int output_val = fdt32_to_cpu(cell[2]);

		if (is_output)
			debug("\tGPIO %d is output, value = %d\n", gpio_num, output_val);
		else
			debug("\tGPIO %d is input\n", gpio_num);

		gpio_cfg[entry_idx].gpio_num = gpio_num;
		gpio_cfg[entry_idx].is_output = is_output;
		gpio_cfg[entry_idx].output_val = output_val;
	}

	err = gpio_board_init(gpio_cfg, len);
	if (err) {
		printf("%s: board gpio initialization failed!\n", __func__);
		return err;
	}

	return 0;
};

static int dt_based_init_gpio_expander(int num)
{
	int off, i;
	const u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	char *compatible;

	u32 expander_address;
	u32 ngpio;
	u32 chip_type;
	struct pca953x_chip_ngpio *chip_ngpios = NULL;
	u32 chip_ngpios_len;

	u32 lines_initial_states, lines_initial_vals;
	int err;
	char path[64];

	for (i = 0; i < num; i++) {
		if (i == 0)
			/* backward compatible */
			off = fdt_path_offset(working_fdt, "/soc/i2c-pld/gpio");
		else {
			sprintf(path, "/soc/i2c-pld/gpio%d", i);
			off = fdt_path_offset(working_fdt, path);
		}

		if (off < 0) {
			debug("%s: gpio expander node not found!\n", __func__);
			return 0;
		}

		debug("GPIO Expander:\n");

		fdt_prop = fdt_get_property(working_fdt, off, "compatible", &len);
		if (!fdt_prop) {
			printf("%s: property '%s' missing\n", __func__, "compatible");
			return -EINVAL;
		}
		compatible = (char *)fdt_prop->data;
		if (strncmp(compatible, "nxp,pca9575", 11) == 0) {
			chip_type = PCA957X_TYPE;
			ngpio = 16;
			debug("\tgpio expander = %s\n", compatible);
		} else {
			printf("%s: unknown gpio expander chip in DT under i2c_pld node: %s\n", __func__,
				compatible);
			return -EINVAL;
		}

		fdt_prop = fdt_get_property(working_fdt, off, "reg", &len);
		if (!fdt_prop) {
			printf("%s: property '%s' missing\n", __func__, "reg");
			return -EINVAL;
		}
		cell = (u32 *)fdt_prop->data;
		expander_address = fdt32_to_cpu(cell[0]);
		debug("\tgpio expander address (on i2c bus) = 0x%x\n", expander_address);

		fdt_prop = fdt_get_property(working_fdt, off, "lines-initial-states", &len);
		if (!fdt_prop) {
			lines_initial_states = 0x0000ffff;
			debug("\tUsing default value for lines-initial-states\n");
		} else {
			cell = (u32 *)fdt_prop->data;
			lines_initial_states = fdt32_to_cpu(cell[0]);
		}
		debug("\tgpio expander lines-initial-states = 0x%x\n", lines_initial_states);

		fdt_prop = fdt_get_property(working_fdt, off, "lines-initial-vals", &len);
		if (!fdt_prop) {
			lines_initial_vals = 0;
			debug("\tUsing default value for lines-initial-vals\n");
		} else {
			cell = (u32 *)fdt_prop->data;
			lines_initial_vals = fdt32_to_cpu(cell[0]);
		}
		debug("\tgpio expander lines-initial-vals = 0x%x\n", lines_initial_vals);

		chip_ngpios_len = pca953x_get_chip_array(&chip_ngpios);
		if (!chip_ngpios_len) {
			printf("%s: Error in obtaining pointer to pca953x_chip_ngpios!\n", __func__);
			return -EINVAL;
		}
		chip_ngpios[0].chip_type = chip_type;
		chip_ngpios[0].ngpio = ngpio;
		chip_ngpios[0].chip = (uint8_t)expander_address;

		/* ~lines_initial_states is used as mask since bits set to 0 are configured as outputs*/
		if ((~lines_initial_states  & lines_initial_vals) != lines_initial_vals) {
			printf("%s: Trying to set a value to a gpio line ", __func__);
			printf("which hasn't been initialized as an output!\n");
		}

		err = pca953x_set_val((uint8_t)expander_address, ~lines_initial_states, lines_initial_vals);
		if (err < 0) {
			printf("%s: gpio expander values initialization failed!\n", __func__);
			return -EINVAL;
		}
		err = pca953x_set_dir((uint8_t)expander_address, AL_FIELD_MASK(ngpio-1, 0),
				lines_initial_states);

		if (err < 0) {
			printf("%s: gpio expander direction initialization failed!\n", __func__);
			return -EINVAL;
		}
	}
	return 0;
}

int dt_get_gpio_by_name(char *name, int off) {
	const struct fdt_property *fdt_prop;
	const u32 *cell;
	int len;
	int gpio = -1;
	int offset = 0;
	fdt_prop = fdt_get_property(working_fdt, off, name, &len);
	if (fdt_prop) {
		cell = (u32 *)fdt_prop->data;
		gpio = fdt32_to_cpu(cell[1]);

		off = fdt_node_offset_by_phandle(working_fdt, fdt32_to_cpu(cell[0]));
		fdt_prop = fdt_get_property(working_fdt, off, "baseidx", &len);
		if (fdt_prop) {
			cell = (u32 *)fdt_prop->data;
			offset = fdt32_to_cpu(cell[0]);
		}

		gpio += offset;
	}
	return gpio;
}

static int dt_based_init_eth_params_port(int port_idx)
{
	const struct fdt_property *fdt_prop;
	const char *prop;
	const u32 *cell;
	char path[80];
	int off;
	int len;
	int tmp;
	struct al_eth_board_params *params =
		&al_globals.eth_board_params[port_idx];

	debug("Ethernet port %d:\n", port_idx);

	sprintf(path, "/soc/board-cfg/ethernet/port%d", port_idx);
	off = fdt_path_offset(working_fdt, path);
	if (off < 0) {
		printf("%s: ethernet port %d initialization node not found!\n",
			__func__, port_idx);
		return -EINVAL;
	}

	prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
	debug("\tstatus: %s\n", prop ? prop : "unknown - assuming enabled");
	if (prop && strcmp(prop, "enabled"))
		return 0;

	prop = (char *)fdt_getprop(working_fdt, off, "mode", NULL);
	debug("\tmode: %s\n", prop ? prop : "<unknown>");
	if (!prop)
		return -EINVAL;

	if (!strcmp(prop, "rgmii")) {
		params->media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	} else {
		if (!strcmp(prop, "sgmii")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_SGMII;
		} else if (!strcmp(prop, "sgmii-2.5g")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_SGMII_2_5G;
		} else if (!strcmp(prop, "10g-serial")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_10GBASE_SR;
		} else if (!strcmp(prop, "auto-detect-auto-speed")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT_AUTO_SPEED;
			params->sfp_plus_module_exist = AL_TRUE;
		} else if (!strcmp(prop, "auto-detect")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT;
			params->sfp_plus_module_exist = AL_TRUE;
		} else if (!strcmp(prop, "nbase-t")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_NBASE_T;
		} else if (!strcmp(prop, "25g")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_25G;
		} else if (!strcmp(prop, "25g-10g-auto-detect")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_25G_10G_AUTO;
		} else if (!strcmp(prop, "40g")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_40G;
		/* backward compatibility */
		} else if (!strcmp(prop, "auto")) {
			printf("\tusing mode auto is deprecated! use auto-detect mode instead\n");
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT;
			params->sfp_plus_module_exist = AL_TRUE;
		} else {
			return -EINVAL;
		}

		fdt_prop = fdt_get_property(working_fdt, off, "serdes-grp", &len);
		if (fdt_prop) {
			int serdes_grp;

			cell = (u32 *)fdt_prop->data;
			serdes_grp = fdt32_to_cpu(cell[0]);
			debug("\tSerdes group: %d\n", serdes_grp);
			params->serdes_grp = serdes_grp;
		} else {
			debug("\tSerdes group is missing\n");
			params->serdes_grp = 3;
		}

		fdt_prop = fdt_get_property(working_fdt, off, "serdes-lane", &len);
		if (fdt_prop) {
			int serdes_lane;

			cell = (u32 *)fdt_prop->data;
			serdes_lane = fdt32_to_cpu(cell[0]);
			debug("\tSerdes lane: %d\n", serdes_lane);
			params->serdes_lane = serdes_lane;
		} else {
			debug("\tSerdes lane is missing\n");
			params->serdes_lane = 3 - port_idx;
		}

		fdt_prop = fdt_get_property(working_fdt, off, "gpio-sfp-present", &len);
		if (fdt_prop) {
			int gpio_sfp_present;

			cell = (u32 *)fdt_prop->data;
			gpio_sfp_present = fdt32_to_cpu(cell[0]);
			if (gpio_sfp_present == 0)
				printf("GPIO 0 can't be used as SFP present\n");

			debug("\tSFP present: %d\n", gpio_sfp_present);
			params->gpio_sfp_present = gpio_sfp_present;
		} else {
			debug("\tNo gpio for SFP present\n");
		}

		/* LED 1g */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/leds/sfp_1g", port_idx);
		off = fdt_path_offset(working_fdt, path);
                tmp = dt_get_gpio_by_name("gpios", off);
                if (tmp > 0) {
			params->gpio_spd_1g = tmp;
			debug("\t10 speed indication GPIO: %d\n", tmp);
                } else {
			params->gpio_spd_1g = 0;
			debug("\tNo gpio for 1G speed indication\n");
                }


		/* LED 10g */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/leds/sfp_10g", port_idx);
		off = fdt_path_offset(working_fdt, path);
                tmp = dt_get_gpio_by_name("gpios", off);
                if (tmp > 0) {
			params->gpio_spd_10g = tmp;
			debug("\t10G speed indication GPIO: %d\n", tmp);
                } else {
			params->gpio_spd_10g = 0;
			debug("\tNo gpio for 10G speed indication\n");
                }

		/* LED 25g */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/leds/sfp_25g", port_idx);
		off = fdt_path_offset(working_fdt, path);
                tmp = dt_get_gpio_by_name("gpios", off);
                if (tmp > 0) {
			params->gpio_spd_25g = tmp;
			debug("\t25G speed indication GPIO: %d\n", tmp);
                } else {
			params->gpio_spd_25g = 0;
			debug("\tNo gpio for 25G speed indication\n");
                }

		/* backward compatibility - replaced with auto-detect mode */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/sfp-plus", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off >= 0) {
			printf("\tusing sfp-plus is deprecated! use auto-detect mode instead\n");
			prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
			debug("\tSFP module status: %s\n", prop ? prop : "<unknown>");
			if (!prop || !strcmp(prop, "enabled")) {
				debug("\tSFP module: enabled\n");
				params->sfp_plus_module_exist = AL_TRUE;
			} else {
				debug("\tSFP module: disabled\n");
			}
		} else {
			debug("\tSFP module: N/A\n");
		}

		/* backward compatibility - shouldn't be under sfp-plus */
		if ((off >= 0) && (params->sfp_plus_module_exist == AL_TRUE)) {
			fdt_prop = fdt_get_property(working_fdt, off, "i2c-id", &len);
			if (fdt_prop) {
				int i2c_id;

				cell = (u32 *)fdt_prop->data;
				i2c_id = fdt32_to_cpu(cell[0]);
				debug("\tSFP module I2C ID: %d\n", i2c_id);
				params->i2c_adapter_id = i2c_id;
			} else {
				debug("\tproperty i2c-id is missing\n");
				params->i2c_adapter_id = 0;
			}
		}

		sprintf(path, "/soc/board-cfg/ethernet/port%d/10g-serial", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off < 0) {
			/* backward compatibility */
			sprintf(path, "/soc/board-cfg/ethernet/port%d/10gbe", port_idx);
			off = fdt_path_offset(working_fdt, path);
			if (off >= 0)
				printf("\tusing 10gbe is deprecated! use 10g-serial instead\n");
		}

		if (off >= 0) {
			prop = (char *)fdt_getprop(working_fdt, off, "dac", NULL);
			debug("\t10gbe DAC: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->dac = AL_TRUE;

			fdt_prop = fdt_get_property(working_fdt, off, "dac-length", &len);
			if (fdt_prop) {
				int len;

				cell = (u32 *)fdt_prop->data;
				len = fdt32_to_cpu(cell[0]);
				if ((len > 0) && (len < 16)) {
					debug("\t10gbe DAC len: %d\n", len);
					params->dac_len = len;
				} else {
					printf("dac-length has non-valid value. default to 3\n");
					params->dac_len = 3;
				}
			} else {
				params->dac_len = 3;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "auto-neg", NULL);
			debug("\t10gbe auto-neg: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->autoneg_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "link-training", NULL);
			debug("\t10gbe link-training: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->kr_lt_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "fec", NULL);
			debug("\tfec: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->kr_fec_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "auto-fec", NULL);
			debug("\tauto-fec: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->auto_fec_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "force-1000base-x", NULL);
			if (prop && !strcmp(prop, "enabled")) {
				params->force_1000_base_x = AL_TRUE;
			} else if (prop && !strcmp(prop, "disabled")) {
				params->force_1000_base_x = AL_FALSE;
			} else {
				params->force_1000_base_x = AL_FALSE;
			}

		} else {
			debug("\t10gbe params: N/A\n");
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/ext_phy", port_idx);
	off = fdt_path_offset(working_fdt, path);

	if (off < 0) {
		/* backward compatibility */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/rgmii", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off >= 0)
			printf("\tusing rgmii is deprecated! use ext_phy instead\n");
	}

	if (off >= 0) {
		int phy_addr;

		params->phy_exist = AL_TRUE;
		fdt_prop = fdt_get_property(working_fdt, off, "phy-addr", &len);
		if (!fdt_prop) {
			/* RGMII must have phy addr */
			if (params->media_type == AL_ETH_BOARD_MEDIA_TYPE_RGMII) {
				printf("\tproperty phy-addr is missing\n");
				params->phy_mdio_addr = 0;
			} else {
				debug("\tphy is not exist\n");
			}
		} else {
			cell = (u32 *)fdt_prop->data;
			phy_addr = fdt32_to_cpu(cell[0]);
			debug("\tPHY address: %d\n", phy_addr);
			params->phy_mdio_addr = phy_addr;

			prop = (char *)fdt_getprop(working_fdt, off, "phy_mgmt_if", NULL);
			if (prop && !strcmp(prop, "mdc-mdio")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
			} else if (prop && !strcmp(prop, "xmdc-xmdio")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_XMDIO;
			} else if (prop && !strcmp(prop, "i2c")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_I2C;
			} else {
				printf("\tphy management interface is missing\n");
				params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "mdc-mdio-freq", NULL);
			if (prop && !strcmp(prop, "2.5Mhz")) {
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_2_5_MHZ;
			} else if (prop && !strcmp(prop, "1.0Mhz")) {
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
			} else {
				debug("\tmdc-mdio-freq is missing\n");
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "auto-neg-mode", NULL);
			if (prop && !strcmp(prop, "in-band")) {
				params->an_mode = AL_ETH_BOARD_AUTONEG_IN_BAND;
			} else if (prop && !strcmp(prop, "out-of-band")) {
				params->an_mode = AL_ETH_BOARD_AUTONEG_OUT_OF_BAND;
			} else {
				printf("\tauto-negotiation mode is missing\n");
				params->an_mode = AL_ETH_BOARD_AUTONEG_OUT_OF_BAND;
			}
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/1g-serial", port_idx);
	off = fdt_path_offset(working_fdt, path);
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "auto-neg", NULL);
		if (prop && !strcmp(prop, "enabled")) {
			params->an_disable = AL_FALSE;
		} else if (prop && !strcmp(prop, "disabled")) {
			params->an_disable = AL_TRUE;
		} else {
			debug("\tauto-neg is missing. assume auto-neg enabled\n");
			params->an_disable = AL_FALSE;
		}

		prop = (char *)fdt_getprop(working_fdt, off, "speed", NULL);
		if (prop && !strcmp(prop, "1000M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_1000M;
		} else if (prop && !strcmp(prop, "100M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_100M;
		} else if (prop && !strcmp(prop, "10M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_10M;
		} else {
			debug("\tspeed is missing. assume speed 1000M\n");
			params->speed = AL_ETH_BOARD_1G_SPEED_1000M;
		}

		prop = (char *)fdt_getprop(working_fdt, off, "duplex", NULL);
		if (prop && !strcmp(prop, "full")) {
			params->half_duplex = AL_FALSE;
		} else if (prop && !strcmp(prop, "half")) {
			params->half_duplex = AL_TRUE;
		} else {
			debug("\tduplex is missing. assume full duplex\n");
			params->half_duplex = AL_FALSE;
		}

		prop = (char *)fdt_getprop(working_fdt, off, "force-1000base-x", NULL);
		if (prop && !strcmp(prop, "enabled")) {
			params->force_1000_base_x = AL_TRUE;
		} else if (prop && !strcmp(prop, "disabled")) {
			params->force_1000_base_x = AL_FALSE;
		} else {
			debug("\tforce-1000base-x is missing. assume sgmii\n");
			params->force_1000_base_x = AL_FALSE;
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/retimer", port_idx);
	off = fdt_path_offset(working_fdt, path);

	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "exist", NULL);
		debug("\tretimer exist: %s\n", prop ? prop : "<unknown>");
		if (prop && !strcmp(prop, "enabled")) {
			params->retimer_exist = AL_TRUE;
			prop = (char *)fdt_getprop(working_fdt, off, "type", NULL);
			if (prop && !strcmp(prop, "br410")) {
				params->retimer_type = AL_ETH_RETIMER_BR_410;
			} else if (prop && !strcmp(prop, "ds25")) {
				params->retimer_type = AL_ETH_RETIMER_DS_25;
			} else if (prop && !strcmp(prop, "ds125")) {
				params->retimer_type = AL_ETH_RETIMER_DS_125;
			} else {
				/* for backward compatibility assume BR_210
				 * retimer in case type is not exist.
				 */
				params->retimer_type = AL_ETH_RETIMER_BR_210;
			}

			fdt_prop = fdt_get_property(working_fdt, off, "i2c-bus", &len);
			if (fdt_prop) {
				cell = (u32 *)fdt_prop->data;
				params->retimer_bus_id = fdt32_to_cpu(cell[0]);
				debug("\tRetimer I2C bus ID: %d\n", params->retimer_bus_id);
			} else {
				printf("\tRetimer bus id: N/A\n");
			}

			fdt_prop = fdt_get_property(working_fdt, off, "i2c-addr", &len);
			if (fdt_prop) {
				cell = (u32 *)fdt_prop->data;
				params->retimer_i2c_addr = fdt32_to_cpu(cell[0]);
				debug("\tRetimer I2C address: %d\n", params->retimer_i2c_addr);
			} else {
				printf("\tRetimer bus addr: N/A\n");
			}

			prop = (char *)fdt_getprop(working_fdt, off, "channel", NULL);
			if (prop && !strcmp(prop, "A")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_A;
			} else if (prop && !strcmp(prop, "B")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_B;
			} else if (prop && !strcmp(prop, "C")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_C;
			} else if (prop && !strcmp(prop, "D")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_D;
			} else if (prop && !strcmp(prop, "E")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_E;
			} else if (prop && !strcmp(prop, "F")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_F;
			} else if (prop && !strcmp(prop, "G")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_G;
			} else if (prop && !strcmp(prop, "H")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_H;
			} else {
				printf("\tretimer channel is missing\n");
			}

			if (params->retimer_type == AL_ETH_RETIMER_DS_25) {
				prop = (char *)fdt_getprop(working_fdt, off, "tx_channel", NULL);
				if (prop && !strcmp(prop, "A"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_A;
				else if (prop && !strcmp(prop, "B"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_B;
				else if (prop && !strcmp(prop, "C"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_C;
				else if (prop && !strcmp(prop, "D"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_D;
				else if (prop && !strcmp(prop, "E"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_E;
				else if (prop && !strcmp(prop, "F"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_F;
				else if (prop && !strcmp(prop, "G"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_G;
				else if (prop && !strcmp(prop, "H"))
					params->retimer_tx_channel = AL_ETH_RETIMER_CHANNEL_H;
				else
					printf("\tretimer tx channel is missing\n");
			}
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/", port_idx);
	off = fdt_path_offset(working_fdt, path);

	fdt_prop = fdt_get_property(working_fdt, off, "i2c-id", &len);

	if (fdt_prop) {
		int i2c_id;

		cell = (u32 *)fdt_prop->data;
		i2c_id = fdt32_to_cpu(cell[0]);
		debug("\tSFP module I2C ID: %d\n", i2c_id);
		params->i2c_adapter_id = i2c_id;
	} else {
		debug("\ti2c-id: N/A\n");
	}

	prop = (char *)fdt_getprop(working_fdt, off, "freeze-serdes-params", NULL);
	if ((prop) && (!strcmp(prop, "enable")))
		params->dont_override_serdes = AL_TRUE;
	else
		params->dont_override_serdes = AL_FALSE;

	return 0;
}

static int dt_based_init_eth_params(void)
{
	enum al_eth_ref_clk_freq eth_ref_clk_freq =
		eth_board_params_ref_clk_freq_get();
	int err = 0;
	int i;

	/* No Ethernet on Alpine V3 TC */
	if ((al_globals.dev_id == PBS_UNIT_CHIP_ID_DEV_ID_ALPINE_V3) && (al_globals.rev_id == 0))
		return 0;

	/* Update Ethernet board params */
	memset(al_globals.eth_board_params, 0, sizeof(al_globals.eth_board_params));

	for (i = 0; i < AL_ETH_NUM; i++) {
		struct al_eth_board_params *board_params = &al_globals.eth_board_params[i];

		board_params->ref_clk_freq = eth_ref_clk_freq;

		if (dt_based_init_eth_params_port(i)) {
			err = -EINVAL;

			switch (i) {
			case 1:
				board_params->sfp_plus_module_exist = AL_FALSE;
				board_params->media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
				board_params->phy_exist = AL_TRUE;
				board_params->phy_mdio_addr = AL_ETH_PHY_ADDR_ETH1;
				board_params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
				board_params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
				break;
			case 3:
				board_params->sfp_plus_module_exist = AL_FALSE;
				board_params->media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
				board_params->phy_exist = AL_TRUE;
				board_params->phy_mdio_addr = AL_ETH_PHY_ADDR_ETH3;
				board_params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
				board_params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
			default:
				board_params->sfp_plus_module_exist = AL_TRUE;
				board_params->phy_exist = AL_FALSE;
				board_params->media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
				break;
			}
		}
	}

	return err;
}

static int dt_based_init_pcie(void)
{
	int off;
	const char *prop;

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/pcie");
	if (off < 0) {
		debug("%s: pcie initialization node not found!\n", __func__);
		return 0;
	}

	prop = (char *)fdt_getprop(working_fdt, off, "rc-manual-init", NULL);
	debug("PCIe root-complex manual init: %s\n", prop ? prop : "<unknown>");
	al_globals.pcie_rc_manual_init = (prop && (!strcmp(prop, "enabled")));

	return 0;
};

static void dt_based_init_i2c(void)
{
	const char *prop;
	int off;

	/* Change the default i2c mux address */
#ifndef CONFIG_SYS_I2C_DIRECT_BUS
	off = fdt_path_offset(working_fdt, "/soc/i2c-pld/i2c_mux");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		int len;
		u32 mux_addr = 0;

		fdt_prop = fdt_get_property(working_fdt, off, "reg", &len);
		if (fdt_prop) {
			u32 *cell = (u32 *)fdt_prop->data;
			mux_addr = fdt32_to_cpu(cell[0]);
		}

		if (mux_addr && (mux_addr != CONFIG_AL_I2C_MUX_DEFAULT_ADDR)) {
			int i;

			for (i = 0; i < CONFIG_SYS_NUM_I2C_BUSES; i++) {
				int j;

				for (j = 0; j < CONFIG_SYS_I2C_MAX_HOPS; j++) {
					if (i2c_bus[i].next_hop[j].chip == 0)
						break;
					if (i2c_bus[i].next_hop[j].chip ==
							CONFIG_AL_I2C_MUX_DEFAULT_ADDR)
						i2c_bus[i].next_hop[j].chip = mux_addr;
				}
			}
		}
	}
#endif

	/*
	 * Determine I2C mux channel 0 bus ID according to the presence of a secondary
	 * I2C controller.
	 * - If there's a secondary I2C controller, the I2C mux channel 0 bus ID is 2.
	 * - Otherwise it is 1.
	 * - This is dictated by Linux behavior.
	 */
	off = fdt_path_offset(working_fdt, "/soc/i2c-gen");
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
		if (!prop && strcmp(prop, "disabled")) {
			i2c_mux_ch0_bus_id += 1;
			debug("%s: i2c_mux_ch0_bus_id = %u\n", __func__, i2c_mux_ch0_bus_id);
		}
	}

	/* Configure sda hold time of I2C controller */
	off = fdt_path_offset(working_fdt, "/soc/i2c-pld");
	debug("\t\n");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		int len;

		debug("I2C-PLD Configuration:\n");
		fdt_prop = fdt_get_property(working_fdt, off, "i2c-sda-hold-time-ns", &len);
		if (fdt_prop) {
			if (len != 0) {
				unsigned int sda_hold_time;
				const u32 *cell;
				cell = (u32 *)fdt_prop->data;
				sda_hold_time = fdt32_to_cpu(cell[0]);
				debug("\tsda hold time is %uns\n", sda_hold_time);

				i2c_set_sda_hold_time(sda_hold_time);
			} else {
				printf("i2c-sda-hold-time-ns isn't defined correctly!\n");
			}
		} else {
			debug("\ti2c-sda-hold-time-ns doesn't exist\n");
		}
	}
}

static void dt_based_init(void)
{
	const char *prop;
	int off;

	debug("DT info:\n");
	debug("--------------------\n");

	off = fdt_path_offset(working_fdt, "/soc/board-cfg");
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "id", NULL);
		if (prop) {
			printf("Board config ID: %s\n", prop);
		} else {
			printf("%s: board id property not found!\n",
				__func__);
		}
	} else {
		printf("%s: board cfg initialization node not found!\n",
			__func__);
	}

#ifdef CONFIG_AL_TRACE
	al_serial_trace_init_dt_based();
#endif

	/* Set SPI baud rate according to DT */
	al_spi_baud_rate_set(AL_SPI_BAUD_RATE_DEFAULT);
	off = fdt_path_offset(working_fdt, "/soc/spi/spiflash@0");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		u32 *cell;
		int len;

		fdt_prop = fdt_get_property(working_fdt, off, "spi-max-frequency", &len);
		if (fdt_prop) {
			cell = (u32 *)fdt_prop->data;
			al_spi_baud_rate_set(fdt32_to_cpu(cell[0]));
		}
	}

	/* Set NAND max ONFI timing mode according to DT */
	al_nand_max_onfi_timing_mode_set(AL_NAND_MAX_ONFI_TIMING_MODE_DEFAULT);
	off = fdt_path_offset(working_fdt, "/soc/nand-flash");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		u32 *cell;
		int len;

		fdt_prop = fdt_get_property(working_fdt, off, "max-onfi-timing-mode", &len);
		if (fdt_prop) {
			cell = (u32 *)fdt_prop->data;
			al_nand_max_onfi_timing_mode_set(fdt32_to_cpu(cell[0]));
		}
	}

	/* I2C init */
	dt_based_init_i2c();

	if (dt_based_init_pinctrl())
		printf("%s: pinctrl initialization failed!\n", __func__);

	if (dt_based_init_gpio())
		printf("%s: gpio initialization failed!\n", __func__);
#ifdef CONFIG_SYS_I2C_PCA953X_DEV_NUM
	if (dt_based_init_gpio_expander(CONFIG_SYS_I2C_PCA953X_DEV_NUM))
#else
	if (dt_based_init_gpio_expander(1))
#endif
		printf("%s: gpio expander initialization failed!\n", __func__);

	if (dt_based_sgpo_init(working_fdt))
		printf("%s: sgpo initialization failed!\n", __func__);

	if (dt_based_init_eth_params())
		printf("%s: ETH params initialization failed!\n", __func__);

	if (dt_based_init_pcie())
		printf("%s: pcie initialization failed!\n", __func__);

	/* SB PLL Initialization */
	/* PCIe set configuration */

	return;
}

unsigned int board_i2c_bus_id_convert(unsigned int id)
{
	if (id >= i2c_mux_ch0_bus_id) {
		id -= i2c_mux_ch0_bus_id;
		id += 1;
	}

	return id;
}


#define THERMAL_SENS_MEASUR_CONVER_TIMEOUT	50000 /* (50 msec) */
#define THERMAL_SENS_PWR_UP_INIT_TIMEOUT	1000  /* (1 msec) */

static int thermal_init(void)
{
	unsigned int			watchdog = 0;

	if (al_globals.dev_id > PBS_UNIT_CHIP_ID_DEV_ID_ALPINE_V2) {
		printf("%s: skipped for Alpine V3\n", __func__);
		return 0;
	}

#if (AL_DEV_ID == AL_DEV_ID_ALPINE_V3) && (AL_DEV_REV_ID == 0)
	struct al_thermal_sensor_handle_init_params init_params = {
		.pbs_regs_base = (void __iomem *)AL_PBS_REGFILE_BASE,
		.sbus_obj = &al_globals.thermal_sensor_sbus_handle,
		.sbus_slave_addr = AL_SBUS_ADDR_THERMAL_SENSOR,
	};

	al_sbus_handle_init(
		&al_globals.thermal_sensor_sbus_handle, (void *)AL_PBS_SBUS_MASTER_BASE);
	al_thermal_sensor_handle_init_ex(&al_globals.thermal_sensor_handle, &init_params);
#else
	al_thermal_sensor_handle_init(
		&al_globals.thermal_sensor_handle,
		(void __iomem *)AL_TEMP_SENSOR_BASE,
		(void __iomem *)AL_PBS_REGFILE_BASE);
#endif

	al_thermal_sensor_enable_set(&al_globals.thermal_sensor_handle, 1);

	/* Wait till Thermal Sensor Powered ON and pass init stage */
	while (!al_thermal_sensor_is_ready(&al_globals.thermal_sensor_handle)) {
		udelay(1);
		watchdog++;
		if (watchdog == THERMAL_SENS_PWR_UP_INIT_TIMEOUT) {
			al_err("Thermal sensor failed to power up or initialized\n");
			return -ETIME;
		}
	}

	/* Set thermal sensor work mode to continuous running */
	al_thermal_sensor_trigger_continuous(&al_globals.thermal_sensor_handle);

	return 0;
}

#if (AL_DEV_ID <= AL_DEV_ID_ALPINE_V2)
static int thermal_get(void)
{
	unsigned int			watchdog = 0;
	int				temp_val;

	while (!al_thermal_sensor_readout_is_valid(&al_globals.thermal_sensor_handle)) {
		udelay(1);
		watchdog++;
		if (watchdog == THERMAL_SENS_MEASUR_CONVER_TIMEOUT) {
			al_err("Thermal sensor failed to measure and convert result\n");
			return -ETIME;
		}
	}

	temp_val = al_thermal_sensor_readout_get(&al_globals.thermal_sensor_handle);

	return temp_val;
}
#endif

/*
 * Routine: board_init
 * Description: Early hardware init.
 */
int board_init(void)
{
	struct al_pbs_regs __iomem *pbs_regs =
		(struct al_pbs_regs __iomem *)AL_PBS_REGFILE_BASE;
	uint32_t reg_val;
	int err = 0;
	int group = 0;

#ifdef CONFIG_AL_TRACE
	al_serial_trace_init_early();
#endif

	printf("\n");
	printf("   _\n");
	printf("  /_\\  _ __  _ __   __ _ _ __  _   _ _ __ _ __   __ _\n");
	printf(" //_\\\\| '_ \\| '_ \\ / _` | '_ \\| | | | '__| '_ \\ / _` |\n");
	printf("/  _  \\ | | | | | | (_| | |_) | |_| | |  | | | | (_| |\n");
	printf("\\_/ \\_/_| |_|_| |_|\\__,_| .__/ \\__,_|_|  |_| |_|\\__,_|\n");
	printf("   __       _           |_|\n");
	printf("  / /  __ _| |__  ___\n");
	printf(" / /  / _` | '_ \\/ __|\n");
	printf("/ /__| (_| | |_) \\__ \\\n");
	printf("\\____/\\__,_|_.__/|___/\n");
	printf("               ___             _\n");
	printf(" /\\ /\\        / __\\ ___   ___ | |_\n");
	printf("/ / \\ \\_____ /__\\/// _ \\ / _ \\| __|\n");
	printf("\\ \\_/ /_____/ \\/  \\ (_) | (_) | |_\n");
	printf(" \\___/      \\_____/\\___/ \\___/ \\__|\n");
	printf("\n");

	/* Read chip device and device revision ID */
	reg_val = readl(&pbs_regs->unit.chip_id);
	al_globals.dev_id = (reg_val & PBS_UNIT_CHIP_ID_DEV_ID_MASK) >>
		PBS_UNIT_CHIP_ID_DEV_ID_SHIFT;
	al_globals.rev_id = (reg_val & PBS_UNIT_CHIP_ID_DEV_REV_ID_MASK) >>
		PBS_UNIT_CHIP_ID_DEV_REV_ID_SHIFT;

	/* adress of boot parameters */
	gd->bd->bi_boot_params = 0x00000100;

	err = bootstrap_read_and_parse(
		&al_globals.bootstraps);
	if (err)
		printf("%s: bootstrap_read_and_parse failed!\n", __func__);

	/* SB PLL Initialization */
	err = pll_sb_init(pll_sb_cfg, ARRAY_SIZE(pll_sb_cfg));
	if (err)
		printf("%s: SB PLL initialization failed!\n", __func__);

	/* MPP Mux Initialization (without allocation) */
	err = al_muio_mux_init(
		(void __iomem *)AL_PBS_REGFILE_BASE,
		"muio_mux",
		&al_globals.muio_mux);
	if (err) {
		printf("al_muio_mux_init failed!\n");
		return -1;
	}

	thermal_init();

#if (AL_DEV_ID <= AL_DEV_ID_ALPINE_V2)
	for (group = 0; group < AL_SRDS_NUM_GROUPS; group++) {
		/* SerDes handle initialization */
		err = al_serdes_handle_grp_init(
			(void __iomem *)AL_SERDES_BASE(group),
			(enum al_serdes_group)group,
			&al_globals.serdes[group]);
		if (err) {
			printf("al_serdes_handle_init failed!\n");
			return -1;
		}

		al_serdes_temperature_get_cb_set(&al_globals.serdes[group], thermal_get);

	}
#elif (AL_REV_ID == 0)
	al_serdes_avg_complex_handle_init(
		(void __iomem *)(uintptr_t)AL_SB_SRD_CMPLX_MAIN_BASE,
		(void __iomem *)(uintptr_t)AL_SRD_CMPLX_MAIN_SBUS_MASTER_BASE,
		AL_SRDS_COMPLEX_TYPE_TR_TC_MAIN, NULL, NULL, &al_globals.srds_cmplx_tc_main);
	for (group = 0; group < AL_SRDS_LANES_PER_COMPLEX_TR_TC_MAIN; group++)
		al_serdes_avg_handle_init(
			(void __iomem *)AL_SRD_CMPLX_MAIN_LANE_BASE(group),
			&al_globals.srds_cmplx_tc_main, group,
			&al_globals.srds_cmplx_tc_main_lanes[group]);
#else
	al_err("SerDes handle initialization not implemented!\n");
#endif

#ifdef CONFIG_SPI_FLASH
	spi_init();
#endif

	return err;
}

int power_init_board(void)
{
	int eeprom_per_device_is_valid;

	int err = 0;

	/* PCIe set configuration */
	al_globals.pcie_cfg = pcie_cfg;
	al_globals.pcie_any_link_up = AL_FALSE;

	/* I2C initialization */
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);

	err = eeprom_per_device_init(&eeprom_per_device_is_valid);
	if (err)
		printf("%s: EEPROM per device initialization failed!\n", __func__);
	if (err || (!eeprom_per_device_is_valid))
		printf("%s: EEPROM per device information is not valid - using defaults!\n", __func__);

	/* Device tree read */
	err = dt_read();
	if (err)
		printf("%s: DT reading failed!\n", __func__);

	/* Device tree based initialization */
	dt_based_init();

	lcd_init();

	lcd_cursor_set(0, 0);
	lcd_puts("AL-Boot");
	lcd_cursor_set(1, 0);
	lcd_puts(EXTRAVERSION);

	return 0;
}

static void board_setenv_ifndef(const char *key, const char *val)
{
	if (!getenv(key))
		setenv(key, val);
}

static void board_set_environment(void)
{
	board_setenv_ifndef(
		"fwupd",
		"tftpboot ${tftpdir}uboot_script_fw_update.bin;"
		"source ${loadaddr}");

	if (!getenv("dt_is_from_toc")) {
		if (dt_is_from_toc)
			setenv("dt_is_from_toc", "1");
		else
			setenv("dt_is_from_toc", "0");
	}

	if (!getenv("dt_filename")) {
		if (dt_is_from_toc)
			setenv("dt_filename", "dt.img");
		else
			setenv("dt_filename", "alpine_ubnt.dtb");
	}

	if (recovery)
		setenv("bootcmd", "echo recovery boot command!");
}

int board_late_init(void)
{
	uint8_t *dev_info_buff = (uint8_t *)DEV_INFO_BASE;

#ifdef CONFIG_CMD_DTT
	dtt_init();
#endif

	setenv_hex(DT_OFFSET_STR, dt_offset);
	setenv_hex(I2C_PROBE_ADDR_STR, al_globals.bootstraps.i2c_preload_addr);
	setenv_hex("boot_instance_active", boot_instance_num_active);
	setenv_hex("boot_instance_non_active", boot_instance_num_non_active);
	setenv_hex("env_offset", al_config_env_offset_get());
	if (al_config_env_offset_redund_get())
		setenv_hex("env_offset_redund", al_config_env_offset_redund_get());

	board_set_environment();

	set_working_fdt_addr((ulong)(uintptr_t)working_fdt);

	if (obj_hdr_uboot_script_valid) {
		void *script_buff;
		int err;

		script_buff = malloc(obj_hdr_uboot_script.size);
		if (!script_buff) {
			printf("Failed allocating memory for U-Boot script!\n");
			goto uboot_script_done;
		}

		err = al_flash_obj_data_load((al_flash_dev_read)boot_read,
				obj_hdr_uboot_script_offset, script_buff);
		if (err) {
			printf("Failed loading U-Boot script!\n");
			goto uboot_script_done_free;
		}

		err = source((ulong)script_buff, NULL);
		if (err) {
			printf("Failed executing U-Boot script!\n");
			goto uboot_script_done_free;
		}

uboot_script_done_free:
		free(script_buff);
uboot_script_done:
		;
	}

	if (al_globals.bootstraps.i2c_preload != I2C_PRELOAD_ENABLED)
		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"\n"
			"\n"
			"             I2C Preload Disabled!\n"
			"\n"
			"\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");

	/* No capability enforcement in Alpine V3 */
	if ((al_globals.dev_id < PBS_UNIT_CHIP_ID_DEV_ID_ALPINE_V3) &&
		(!dev_info_buff[DEV_INFO_DEV_ID_0_OFFSET]))
		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"\n"
			"\n"
			"   Bootstraps / DT / Capabilities Mismatch!\n"
			"\n"
			"\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");

	return 0;
}

#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
static void ft_board_setup_clock(
	void		*blob,
	const char	*path,
	const char	*prop,
	uint32_t	cpu_val)
{
	uint32_t fdt_val = cpu_to_fdt32(cpu_val);

	debug("%s: setting %s.%s to %u Hz\n", __func__, path, prop, cpu_val);
	if (fdt_find_and_setprop(
		blob, path, prop, &fdt_val, sizeof(fdt_val), 0))
		printf("%s: unable to set %s.%s!\n", __func__, path, prop);
}

static void ft_board_setup_feature_disable(
	void		*blob,
	const char	*path)
{
	const char *status = "disabled";

	debug("%s: setting %s.status to disabled\n", __func__, path);
	if (fdt_find_and_setprop(
		blob, path, "status", status, strlen(status) + 1, 1))
		printf("%s: unable to set %s.status!\n", __func__, path);
}

static void ft_board_setup_prop_u32_set(
	void		*blob,
	const char	*path,
	const char	*prop,
	uint32_t	val)
{
	uint32_t fdt_val = cpu_to_fdt32(val);

	debug("%s: setting %s.%s to %u\n", __func__, path, prop, val);
	if (fdt_find_and_setprop(
		blob, path, prop, &fdt_val, sizeof(fdt_val), 0))
		printf("%s: unable to set %s.%s!\n", __func__, path, prop);
}

static void ft_board_setup_pcie_set(
	void		*blob,
	const char	*path,
	const char	*prop,
	al_phys_addr_t	base,
	uint32_t	size)
{
	int off;
	u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	int err;

	off = fdt_path_offset(working_fdt, path);
	if (off < 0) {
		printf("%s: %s node not found!\n", __func__, path);
		return;
	}

	fdt_prop = fdt_get_property_w(working_fdt, off, prop, &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, prop);
		return;
	}

	if (len < (PCI_REGS_MEM_SIZE_IDX * sizeof(u32))) {
		printf("%s: property length is smaller then expected\n", __func__);
		return;
	}

	cell = (u32 *)fdt_prop->data;

	cell[PCI_REGS_IO_SYS_BASE_IDX] = cpu_to_fdt32(base);
	base += fdt32_to_cpu(cell[PCI_REGS_IO_SIZE_IDX]);
	size -= fdt32_to_cpu(cell[PCI_REGS_IO_SIZE_IDX]);
	cell[PCI_REGS_MEM_REAL_BASE_IDX] = cpu_to_fdt32(base);
	cell[PCI_REGS_MEM_SYS_BASE_IDX] = cpu_to_fdt32(base);
	cell[PCI_REGS_MEM_SIZE_IDX] = cpu_to_fdt32(size);

	err = fdt_find_and_setprop(working_fdt, path, prop, cell, len, 1);
	if (err) {
		printf("Unable to update property %s, err=%s\n",
		       prop, fdt_strerror(err));
		return;
	}
}

int ft_board_setup(void *blob, bd_t *bd)
{
	struct al_nb_regs __iomem *nb_regs =
		(struct al_nb_regs __iomem *)AL_NB_SERVICE_BASE;
	struct al_pbs_regs __iomem *pbs_regs =
		(struct al_pbs_regs __iomem *)AL_PBS_REGFILE_BASE;
	al_phys_addr_t base;
	uint32_t log2size;
	uint32_t fdt_u32;
	int off;

	ft_board_setup_clock(
		blob, "/soc/clocks/refclk", "clock-frequency",
		al_globals.bootstraps.pll_ref_clk_freq);
	ft_board_setup_clock(
		blob, "/soc/clocks/sbclk", "clock-frequency",
		al_globals.bootstraps.sb_clk_freq);
	ft_board_setup_clock(
		blob, "/soc/clocks/nbclk", "clock-frequency",
		al_globals.bootstraps.ddr_pll_freq);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.cpu_pll_freq);
	do_fixup_by_compat(blob, "arm,cortex-a15", "clock-frequency", &fdt_u32,
			   sizeof(fdt_u32), 0);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.ddr_pll_freq /
		(1 + ((al_reg_read32(&nb_regs->system_counter.cnt_control) &
		NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_MASK) >>
		NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_SHIFT)));
	do_fixup_by_compat(blob, "arm,cortex-a15-timer", "clock-frequency",
			   &fdt_u32, sizeof(fdt_u32), 0);
	do_fixup_by_compat(blob, "arm,armv8-timer", "clock-frequency",
			   &fdt_u32, sizeof(fdt_u32), 0);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.sb_clk_freq);
	do_fixup_by_compat(blob, "ns16550a", "clock-frequency",
			   &fdt_u32, sizeof(fdt_u32), 0);

	if (!al_globals.pcie_cfg[0].present || al_globals.pcie_cfg[0].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external0");
	if (!al_globals.pcie_cfg[1].present || al_globals.pcie_cfg[1].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external1");
	if (!al_globals.pcie_cfg[2].present || al_globals.pcie_cfg[2].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external2");
#if (AL_SB_PCIE_NUM > 3)
	if (!al_globals.pcie_cfg[3].present || al_globals.pcie_cfg[3].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external3");
#endif
	if (getenv_ulong("iocc_force", 10, 0)) {
		unsigned long val = getenv_ulong("iocc_force_val", 10, 1);

		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"I/O CC forced to %lu!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
			val);
		if (fdt_path_offset(blob, "/soc/ccu") >= 0)
			ft_board_setup_prop_u32_set(
				blob, "/soc/ccu", "io_coherency", val);
		else
			ft_board_setup_prop_u32_set(
				blob, "/soc/al-fabric", "io_coherency", val);
	}

	off = fdt_path_offset(blob, "/soc/ccu");
	if (off >= 0) {
		const fdt32_t *reg = fdt_getprop(blob, off, "reg", NULL);
		int io_coherency = fdtdec_get_int(blob, off, "io_coherency", 0);

		if (!reg) {
			printf("Warning: ccu node has no address.\n");
		} else {
			u64 ccu_address = fdt_translate_address(blob, off, reg);
			if (ccu_address)
				al_ccu_init((void __iomem *)(uintptr_t)ccu_address, io_coherency);
		}

		if (io_coherency) {
			do_fixup_by_compat(blob, "annapurna-labs,alpine-internal-pcie",
					   "dma-coherent", NULL, 0, 1);
			do_fixup_by_compat(blob, "annapurna-labs,alpine-external-pcie",
					   "dma-coherent", NULL, 0, 1);
		}
	}

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM0, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external0", "ranges",
				base, AL_BIT(log2size));

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM1, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external1", "ranges",
				base, AL_BIT(log2size));

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM2, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external2", "ranges",
				base, AL_BIT(log2size));

	return 0;
}
#endif

#ifdef CONFIG_BOARD_EARLY_INIT_F
int board_early_init_f(void)
{
	return 0;
}
#endif	/* EARLY_INIT */

int dram_init(void)
{
	struct shared_parameters *shared_params = shared_params_ptr_get();

	if (shared_params->ddr_size > SZ_64M)
		gd->ram_size = SZ_64M;
	else
		gd->ram_size = (phys_size_t)shared_params->ddr_size;

	return 0;
}

void dram_init_banksize(void)
{
	const char *origin;
	uint64_t ddr_size;

	if (shared_params_valid()) {
		struct shared_parameters *shared_params =
			shared_params_ptr_get();

		ddr_size = shared_params->ddr_size;
		origin = "shared params";
	} else {
		ddr_size = SZ_512M;
		origin = "default";
	}

	debug("DDR size is %d MB according to %s\n",
		(int)(ddr_size / SZ_1M), origin);

	/* Define 4 memory banks according to DDR size */
	if (ddr_size == (4 * (uint64_t)SZ_1G)) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000040000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000080000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[3].size =  0x0000000040000000ULL;
	} else if ((ddr_size > (4 * (uint64_t)SZ_1G)) && (ddr_size <= (8 * (uint64_t)SZ_1G))) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000080000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000100000000ULL;
		gd->bd->bi_dram[3].size =  ddr_size - gd->bd->bi_dram[3].start;
	} else if ((ddr_size > (8 * (uint64_t)SZ_1G)) && (ddr_size <= (16 * (uint64_t)SZ_1G))) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000400000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000100000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000100000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[3].size =  ddr_size - gd->bd->bi_dram[3].start;
	} else {
		int i;

		if (ddr_size > SZ_2G) {
			al_err("%s: error DDR size %" PRIu64 " not supported... using 2G size\n",
			       __func__,
			       ddr_size);
			ddr_size = SZ_2G;
		}

		for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
			gd->bd->bi_dram[i].start =
				i * (ddr_size / CONFIG_NR_DRAM_BANKS);
			gd->bd->bi_dram[i].size =
				ddr_size / CONFIG_NR_DRAM_BANKS;
		}
	}
}

#ifdef CONFIG_AL_ETH
struct retimer_params {
	al_bool	valid;
	enum al_eth_retimer_type type;
	uint8_t	bus_id;
	uint8_t	addr;
};

struct retimer_config_reg {
	uint8_t addr;
	uint8_t val;
};

struct retimer_configuration {
	struct retimer_config_reg *config;
	uint32_t size;
};

static struct retimer_config_reg retimer_br210_configuration[] = {
	/* Clearing SMB Register to default. */
	{.addr = 0x7, .val = 0x41},
	/*
	 * Enabling Tx#A and Tx#B.
	 * Enabling Eq Stage 4 on RX#A & Rx#B.
	 */
	{.addr = 0x6, .val = 0x18},
	/*
	 * Enable Overriding Idle thresholds.
	 * Enable Overriding output Mode.
	 * Enable Overriding outputDeEmphasis.
	 */
	{.addr = 0x4, .val = 0x23},
	/* Set #A Normal Equalizer operation mode. */
	{.addr = 0x8, .val = 0x46},
	/* Setting Tx#A DeEmphasis to 0. */
	{.addr = 0x10, .val = 0xed},
	/* Setting Tx#A DeEmphasis to 0. */
	{.addr = 0x11, .val = 0x80},
	/*
	 * Setting Tx#A Idle D Threshold=110mV.
	 * Setting Tx#A Idle A Threshold=180mV.
	 * Setting Tx#A Slow OOB enabled.
	 */
	{.addr = 0x12, .val = 0x80},
	/* Setting Tx#A Amplitude to 700mVpp */
	{.addr = 0x25, .val = 0xad},
	/* Set #B Normal Equalizer operation mode. */
	{.addr = 0x17, .val = 0xed},
	/* Setting Tx#B DeEmphasis to 0. */
	{.addr = 0x18, .val = 0x80},
	/*
	 * Setting Tx#B Idle D Threshold=110mV.
	 * Setting Tx#B Idle A Threshold=180mV.
	 * Setting Tx#B Slow OOB enabled.
	 */
	{.addr = 0x19, .val = 0x80},
	/* Setting Tx#B Amplitude to 700mVpp */
	{.addr = 0x2d, .val = 0xad},
};

static struct retimer_config_reg retimer_br410_configuration[] = {
	/* Allow channel EN and EQ boost to be set by I2C. */
	{.addr = 0x7, .val = 0x1},
	/*
	 *  Set Tx to 1000mV
	 */
	{.addr = 0x8, .val = 0x8},
	/*
	 * Set Tx-DE to 0 for all ports
	 */
	{.addr = 0x11, .val = 0x0},
	/* Enable all channels */
	{.addr = 0x13, .val = 0x10},
	{.addr = 0x15, .val = 0x10},
	{.addr = 0x17, .val = 0x10},
	{.addr = 0x19, .val = 0x10},
	/* OOB Signal Detect Enable */
	{.addr = 0x12, .val = 0x6},
};

static struct retimer_configuration retimer_configuration[AL_ETH_RETIMER_TYPE_MAX] = {
	{.config = retimer_br210_configuration, .size = ARRAY_SIZE(retimer_br210_configuration) },
	{.config = retimer_br410_configuration, .size = ARRAY_SIZE(retimer_br410_configuration) },
	{.config = NULL, .size = 0 },
	{.config = NULL, .size = 0 },
};

int al_eth_retimer_init(uint8_t retimer_type, uint8_t bus_id, uint8_t addr)
{
	int rc = 0;
	int i;
	uint8_t val;
	struct retimer_config_reg *retimer_config = retimer_configuration[retimer_type].config;

	if (!retimer_config) {
		debug("%s: no retimer configuration needed.\n", __func__);
		return 0;
	}

	/* select the correct i2c module by muxing the i2c switch */
	rc = i2c_set_bus_num(bus_id);
	if (rc)
		goto i2c_error;

	rc = i2c_read(addr, 0x51, 1, &val, 1);
	if (rc)
		goto i2c_error;

	debug("%s: retimer id 0x%x\n", __func__, val);

	for (i = 0; i < retimer_configuration[retimer_type].size; i++) {
		debug("%s: (bus: %x, i2c-addr: %x) writing %x to i2c addr %x\n",
		      __func__, bus_id, addr, retimer_config[i].val,
		      retimer_config[i].addr);
		rc = i2c_write(addr,
			       retimer_config[i].addr,
			       1,
			       &retimer_config[i].val,
			       1);
		if (rc)
			goto i2c_error;
	}

	return 0;

i2c_error:
	printf("%s: Configuring retimer failed (%02x:%02x). assume no retimer exist\n", __func__, bus_id, addr);
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
	return rc;
}

int board_eth_init(bd_t *bis)
{
	int port;
	int i;
	int err;
	struct retimer_params retimer_params[AL_ETH_NUM] = {
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE } };

	/* No Ethernet on Alpine V3 TC */
	if ((al_globals.dev_id == PBS_UNIT_CHIP_ID_DEV_ID_ALPINE_V3) && (al_globals.rev_id == 0))
		return 0;

	/*
	 * In Alpine revision 0 disable RGMII_A and RGMII_B internal delay
	 * (because PHY applies delay)
	 * In newer revisions this is the default
	 */
	if ((al_globals.dev_id == PBS_UNIT_CHIP_ID_DEV_ID_ALPINE_V1) && (al_globals.rev_id == 0)) {
		struct al_cmos_regs_m0 __iomem *cmos2_regs =
			(struct al_cmos_regs_m0 __iomem *)AL_CMOS_GROUP_BASE(2);
		struct al_cmos_regs_m0 __iomem *cmos3_regs =
			(struct al_cmos_regs_m0 __iomem *)AL_CMOS_GROUP_BASE(3);

		writel(0, &cmos2_regs->rgmii_dly_ctl);
		writel(0, &cmos3_regs->rgmii_dly_ctl);
	}

	for (port = 0; port < AL_ETH_NUM; port++) {
		struct al_eth_board_params *board_params = &al_globals.eth_board_params[port];

		if (board_params->retimer_exist) {
			unsigned int retimer_bus_id = board_i2c_bus_id_convert(board_params->retimer_bus_id);

			for (i = 0; i < AL_ETH_NUM; i++) {
				if (retimer_params[i].valid == AL_FALSE) {
					retimer_params[i].type = board_params->retimer_type;
					retimer_params[i].bus_id = retimer_bus_id;
					retimer_params[i].addr = board_params->retimer_i2c_addr;
					retimer_params[i].valid = AL_TRUE;
					break;
				} else if ((retimer_params[i].valid == AL_TRUE) &&
					(retimer_params[i].bus_id == retimer_bus_id) &&
					(retimer_params[i].addr == board_params->retimer_i2c_addr)) {
					if (retimer_params[i].type != board_params->retimer_type)
						printf("%s: DT indicates two different retimers on the same address\n", __func__);
					break;
				}
			}
		}
	}

	for (i = 0; i < AL_ETH_NUM; i++) {
		if (retimer_params[i].valid == AL_FALSE)
			break;

		err = al_eth_retimer_init(
					retimer_params[i].type,
					retimer_params[i].bus_id,
					retimer_params[i].addr);
		if (err) {
			/*
			 * retimer init failed - go over all ports with this retimer
			 * and mark it as not exist to make boards without retimer
			 * to work.
			 */
			for (port = 0; port < AL_ETH_NUM; port++) {
				struct al_eth_board_params *board_params =
					&al_globals.eth_board_params[port];
				unsigned int retimer_bus_id =
					board_i2c_bus_id_convert(board_params->retimer_bus_id);

				if ((board_params->retimer_exist == true) &&
				    (retimer_params[i].bus_id == retimer_bus_id) &&
				    (retimer_params[i].addr == board_params->retimer_i2c_addr)) {
					board_params->retimer_exist = false;
				}

			}
		}
	}

	return al_eth_pci_probe();
}
#endif

